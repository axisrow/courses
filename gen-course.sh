#!/bin/bash
# Generate all course files
BASE="/data/workspace-test/get-shit-done-course"

# =================== RUSSIAN ===================

# RU Level 1
cat > "$BASE/ru/level-1-beginner/01-what-is-gsd.md" << 'LESSON'
---
title: "Что такое Get Shit Done и зачем он нужен"
level: 1
lesson: 1
language: ru
tags: [gsd, введение, context-rot]
---

# Что такое Get Shit Done и зачем он нужен

## Введение

Вы пишете промпт в Claude Code, получаете отличный результат. Потом ещё один. И ещё. Но через 30-40 сообщений качество начинает падать — ответы становятся короче, код — хуже, а модель «забывает» о ранних решениях. Это называется **context rot** (деградация контекста).

**Get Shit Done (GSD)** — это система мета-промптинга и контекстной инженерии, которая решает эту проблему. Она даёт Claude (или другому AI-агенту) ровно тот контекст, который нужен, в нужный момент.

## Что делает GSD

- Разбивает работу на атомарные задачи, каждая — в свежем контекстном окне
- Управляет состоянием проекта через markdown-файлы
- Оркестрирует подагентов: исследователей, планировщиков, исполнителей
- Автоматически коммитит каждую задачу

## Проблема context rot

| Без GSD | С GSD |
|---------|-------|
| Один длинный диалог | Много коротких сессий |
| Контекст забивается | Каждая задача — свежие 200k токенов |
| Качество падает | Качество стабильно |
| Ручное управление | Автоматическая оркестрация |

## Для кого это

GSD создан для людей, которые хотят описать идею и получить работающий результат — без имитации корпоративных процессов.

## Итоги

- GSD — это мета-промптинг система для Claude Code, OpenCode и Gemini CLI
- Решает проблему деградации контекста (context rot)
- Разбивает работу на атомарные задачи с чистым контекстом
- Не требует знания программирования
LESSON

cat > "$BASE/ru/level-1-beginner/02-installation.md" << 'LESSON'
---
title: "Установка GSD"
level: 1
lesson: 2
language: ru
tags: [gsd, установка, npx]
---

# Установка GSD

## Введение

GSD устанавливается одной командой через npx. Не нужно клонировать репозиторий или настраивать зависимости.

## Инструкции

### Быстрая установка

```bash
npx get-shit-done-cc@latest
```

Установщик спросит:
1. **Runtime** — Claude Code, OpenCode, Gemini или все сразу
2. **Расположение** — Глобально (все проекты) или локально (текущий проект)

### Неинтерактивная установка

```bash
# Claude Code глобально
npx get-shit-done-cc --claude --global

# OpenCode глобально
npx get-shit-done-cc --opencode --global

# Gemini CLI глобально
npx get-shit-done-cc --gemini --global

# Все рантаймы
npx get-shit-done-cc --all --global
```

### Проверка установки

Откройте Claude Code и введите:

```
/gsd:help
```

Если видите список команд — всё работает.

## Примеры

```bash
# Установка для Claude Code в текущий проект
npx get-shit-done-cc --claude --local

# Обновление до последней версии
npx get-shit-done-cc@latest
```

## Итоги

- Установка через `npx get-shit-done-cc@latest`
- Выбираете runtime и расположение (глобально/локально)
- Проверяете через `/gsd:help`
- Обновляете той же командой с `@latest`
LESSON

cat > "$BASE/ru/level-1-beginner/03-first-run.md" << 'LESSON'
---
title: "Первый запуск"
level: 1
lesson: 3
language: ru
tags: [gsd, первый-запуск, new-project]
---

# Первый запуск

## Введение

После установки GSD ваш первый шаг — создать проект. Команда `/gsd:new-project` запускает полный цикл инициализации.

## Инструкции

### 1. Запустите Claude Code

```bash
claude --dangerously-skip-permissions
```

> Флаг `--dangerously-skip-permissions` рекомендуется для GSD — иначе вы будете подтверждать каждую мелкую операцию.

### 2. Создайте проект

```
/gsd:new-project
```

Система пройдёт через 4 этапа:
1. **Вопросы** — спросит о вашей идее, целях, ограничениях
2. **Исследование** — запустит параллельных агентов для изучения домена
3. **Требования** — определит что в v1, v2 и вне скоупа
4. **Дорожная карта** — создаст фазы, привязанные к требованиям

### 3. Утвердите дорожную карту

После создания дорожной карты GSD покажет её вам. Утвердите — и можно строить.

## Что создаётся

```
.planning/
├── PROJECT.md        # Видение проекта
├── REQUIREMENTS.md   # Требования v1/v2
├── ROADMAP.md        # Дорожная карта
├── STATE.md          # Текущее состояние
└── research/         # Результаты исследований
```

## Примеры

```
/gsd:new-project

> Я хочу создать блог-платформу с markdown-редактором,
> авторизацией через GitHub и деплоем на Vercel.
```

## Итоги

- `/gsd:new-project` — точка входа для любого проекта
- Система сама задаёт нужные вопросы
- Создаёт структуру в `.planning/`
- Вы утверждаете дорожную карту перед началом работы
LESSON

cat > "$BASE/ru/level-1-beginner/04-core-commands.md" << 'LESSON'
---
title: "Основные команды GSD"
level: 1
lesson: 4
language: ru
tags: [gsd, команды, workflow]
---

# Основные команды GSD

## Введение

GSD работает через slash-команды внутри Claude Code (или аналогичного рантайма). Основной цикл: обсудить → спланировать → выполнить → проверить.

## Инструкции

### Основной цикл

| Команда | Что делает |
|---------|------------|
| `/gsd:new-project` | Создаёт проект с нуля |
| `/gsd:discuss-phase N` | Обсуждает детали фазы перед планированием |
| `/gsd:plan-phase N` | Исследует и создаёт план |
| `/gsd:execute-phase N` | Выполняет план параллельными волнами |
| `/gsd:verify-work N` | Ручная проверка результата |

### Навигация

| Команда | Что делает |
|---------|------------|
| `/gsd:progress` | Показывает текущий статус |
| `/gsd:help` | Список всех команд |

### Быстрые задачи

```
/gsd:quick
> Добавь кнопку тёмной темы в настройки
```

Для задач, которые не требуют полного планирования.

### Управление фазами

| Команда | Что делает |
|---------|------------|
| `/gsd:add-phase` | Добавить фазу |
| `/gsd:insert-phase N` | Вставить срочную фазу |
| `/gsd:remove-phase N` | Удалить фазу |

### Сессии

| Команда | Что делает |
|---------|------------|
| `/gsd:pause-work` | Сохранить прогресс |
| `/gsd:resume-work` | Восстановить прогресс |

## Примеры

```
/gsd:discuss-phase 1
/gsd:plan-phase 1
/gsd:execute-phase 1
/gsd:verify-work 1

/gsd:discuss-phase 2
/gsd:plan-phase 2
/gsd:execute-phase 2
/gsd:verify-work 2

/gsd:complete-milestone
```

## Итоги

- Основной цикл: discuss → plan → execute → verify
- `/gsd:quick` для мелких задач
- `/gsd:progress` чтобы понять где вы
- `/gsd:pause-work` и `/gsd:resume-work` для сессий
LESSON

cat > "$BASE/ru/level-1-beginner/05-solving-context-rot.md" << 'LESSON'
---
title: "Как GSD решает проблему деградации контекста"
level: 1
lesson: 5
language: ru
tags: [gsd, context-rot, context-engineering]
---

# Как GSD решает проблему деградации контекста

## Введение

Context rot — главная проблема при длительной работе с AI-агентами. GSD решает её архитектурно, а не «подсказками».

## Как возникает context rot

1. Вы начинаете диалог — качество отличное
2. Контекстное окно заполняется на 50% — качество нормальное
3. На 70%+ — модель начинает «забывать» ранние решения
4. На 90%+ — ответы деградируют, код ломается

## Как GSD это решает

### 1. Свежий контекст для каждой задачи

Каждый план выполняется в отдельном подагенте с чистыми 200k токенами. Ничего лишнего — только задача и нужный контекст.

### 2. Файловое состояние вместо памяти диалога

```
PROJECT.md       → Что строим (всегда загружен)
REQUIREMENTS.md  → Что нужно сделать
ROADMAP.md       → Где мы в процессе
STATE.md         → Текущие решения и блокеры
PLAN.md          → Конкретная задача с XML-структурой
```

### 3. Волновое выполнение

Независимые задачи выполняются параллельно, зависимые — последовательно. Ни один агент не перегружен.

### 4. Атомарные коммиты

Каждая задача = один коммит. Если что-то сломалось — откатите один коммит, а не разбирайтесь в каше.

## Примеры

**Без GSD:**
```
Сообщение 1: "Создай API" → отлично
Сообщение 15: "Добавь авторизацию" → нормально
Сообщение 40: "Исправь баг" → забыл половину архитектуры
```

**С GSD:**
```
Фаза 1, План 1: API endpoints → свежий контекст → отлично
Фаза 1, План 2: Авторизация → свежий контекст → отлично
Фаза 2, План 1: Баг-фикс → свежий контекст → отлично
```

## Итоги

- Context rot — неизбежная проблема длинных диалогов
- GSD решает её через свежие контексты для каждой задачи
- Состояние хранится в файлах, а не в памяти диалога
- Атомарные коммиты дают чистую историю
- Качество остаётся стабильным независимо от объёма работы
LESSON

# RU Level 2
cat > "$BASE/ru/level-2-intermediate/01-spec-driven-development.md" << 'LESSON'
---
title: "Spec-driven разработка"
level: 2
lesson: 1
language: ru
tags: [gsd, spec-driven, requirements]
---

# Spec-driven разработка

## Введение

GSD построен на принципе spec-driven development: сначала спецификация, потом код. Вместо «сделай мне сайт» вы получаете структурированные требования, дорожную карту и планы.

## Инструкции

### Структура спецификации

GSD автоматически создаёт:

1. **PROJECT.md** — высокоуровневое видение
2. **REQUIREMENTS.md** — конкретные требования, разделённые на v1/v2/out-of-scope
3. **ROADMAP.md** — фазы с привязкой к требованиям

### Как это работает

```
Ваша идея → Вопросы → Исследование → Требования → Дорожная карта → Планы → Код
```

Каждый шаг сужает неопределённость. К моменту написания кода AI точно знает что делать.

### Планы в XML

```xml
<task type="auto">
  <name>Создать эндпоинт логина</name>
  <files>src/api/auth/login.ts</files>
  <action>
    Использовать jose для JWT.
    Валидировать credentials.
    Вернуть httpOnly cookie.
  </action>
  <verify>curl POST /api/auth/login → 200 + cookie</verify>
  <done>Валидные credentials → cookie, невалидные → 401</done>
</task>
```

## Примеры

```
/gsd:new-project

> Я хочу SaaS для управления задачами с командами,
> канбан-доской и интеграцией со Slack.

GSD создаст:
- PROJECT.md с видением
- REQUIREMENTS.md с ~15-20 конкретных требований
- ROADMAP.md с 4-6 фазами
```

## Итоги

- Spec-driven = спецификация перед кодом
- GSD автоматически генерирует PROJECT, REQUIREMENTS, ROADMAP
- Каждый план — XML-структура с задачей и верификацией
- Неопределённость устраняется до написания кода
LESSON

cat > "$BASE/ru/level-2-intermediate/02-context-engineering.md" << 'LESSON'
---
title: "Контекстная инженерия"
level: 2
lesson: 2
language: ru
tags: [gsd, context-engineering, файлы]
---

# Контекстная инженерия

## Введение

Контекстная инженерия — это искусство давать AI ровно тот контекст, который нужен. Не больше и не меньше. GSD делает это автоматически.

## Инструкции

### Иерархия контекста в GSD

| Файл | Роль | Когда загружается |
|------|------|-------------------|
| `PROJECT.md` | Видение проекта | Всегда |
| `STATE.md` | Текущее состояние, решения | Всегда |
| `ROADMAP.md` | Прогресс | При планировании |
| `REQUIREMENTS.md` | Требования | При планировании |
| `CONTEXT.md` | Решения по фазе | При планировании фазы |
| `RESEARCH.md` | Исследования | При планировании |
| `PLAN.md` | Конкретная задача | При выполнении |

### Лимиты размеров

GSD контролирует размеры файлов — не потому что так удобнее, а потому что качество Claude деградирует при больших контекстах. Каждый файл оптимизирован по размеру.

### Принцип «Need to Know»

Исполнитель (executor) не видит все исследования и все планы. Он видит только:
- PROJECT.md — понимание проекта
- Свой конкретный PLAN.md — что делать
- STATE.md — текущие решения

Это даёт ему чистые 200k токенов для работы.

## Примеры

Плохой контекст:
```
"Помнишь, 30 сообщений назад мы решили использовать PostgreSQL?"
```

Хороший контекст (GSD):
```
STATE.md: database=PostgreSQL, orm=Prisma, deployed=Vercel
```

## Итоги

- Контекстная инженерия = правильный контекст в правильный момент
- Каждый агент получает только нужные файлы
- Размеры файлов контролируются для оптимального качества
- Состояние хранится в файлах, не в памяти диалога
LESSON

cat > "$BASE/ru/level-2-intermediate/03-meta-prompting.md" << 'LESSON'
---
title: "Мета-промптинг"
level: 2
lesson: 3
language: ru
tags: [gsd, meta-prompting, промпты]
---

# Мета-промптинг

## Введение

Мета-промптинг — это когда AI создаёт промпты для других AI. В GSD тонкий оркестратор создаёт задания для специализированных агентов.

## Инструкции

### Архитектура мета-промптинга в GSD

```
Вы → Оркестратор → Исследователи (4 параллельных)
                  → Планировщик → Чекер → (цикл пока не пройдёт)
                  → Исполнители (параллельные волны)
                  → Верификатор
```

### Как работает оркестратор

1. **Никогда не делает тяжёлую работу сам** — только координирует
2. **Создаёт промпты для подагентов** на основе текущего состояния
3. **Собирает результаты** и направляет дальше
4. **Сохраняет контекст главного окна** — ваша сессия остаётся на 30-40%

### XML-форматирование промптов

GSD использует XML для структурирования задач, потому что Claude лучше понимает структурированные промпты:

```xml
<task type="auto">
  <name>Конкретное название</name>
  <files>Какие файлы трогать</files>
  <action>Точные инструкции</action>
  <verify>Как проверить</verify>
  <done>Критерий завершения</done>
</task>
```

## Примеры

Когда вы запускаете `/gsd:plan-phase 1`, оркестратор:
1. Читает PROJECT.md, REQUIREMENTS.md, CONTEXT.md
2. Создаёт промпт для исследователей: «изучи стек, найди паттерны»
3. Собирает исследования → создаёт промпт для планировщика
4. Планировщик создаёт XML-планы
5. Чекер проверяет планы → если не проходят, цикл повторяется

## Итоги

- Мета-промптинг = AI создаёт промпты для AI
- Оркестратор координирует, не делает работу сам
- XML-структура даёт точные инструкции подагентам
- Ваш основной контекст остаётся чистым
LESSON

cat > "$BASE/ru/level-2-intermediate/04-project-configuration.md" << 'LESSON'
---
title: "Настройка под проект"
level: 2
lesson: 4
language: ru
tags: [gsd, настройка, конфигурация]
---

# Настройка под проект

## Введение

GSD гибко настраивается через конфигурацию. Вы можете управлять режимом работы, профилями моделей, git-стратегией и рабочими агентами.

## Инструкции

### Конфигурация

Настройки хранятся в `.planning/config.json`. Изменить можно через `/gsd:settings`.

### Режимы работы

| Настройка | Варианты | По умолчанию |
|-----------|----------|--------------|
| `mode` | `yolo`, `interactive` | `interactive` |
| `depth` | `quick`, `standard`, `comprehensive` | `standard` |

- **yolo** — автоматическое подтверждение на каждом шаге
- **interactive** — подтверждение от вас
- **quick/standard/comprehensive** — глубина планирования

### Профили моделей

```
/gsd:set-profile budget
```

| Профиль | Планирование | Выполнение | Проверка |
|---------|-------------|------------|----------|
| `quality` | Opus | Opus | Sonnet |
| `balanced` | Opus | Sonnet | Sonnet |
| `budget` | Sonnet | Sonnet | Haiku |

### Рабочие агенты

| Агент | По умолчанию | Что делает |
|-------|-------------|------------|
| `research` | включён | Исследует домен перед планированием |
| `plan_check` | включён | Проверяет планы перед выполнением |
| `verifier` | включён | Подтверждает результат после выполнения |
| `auto_advance` | выключен | Автоматическая цепочка discuss→plan→execute |

### Git-стратегии

| Стратегия | Что делает |
|-----------|------------|
| `none` | Коммиты в текущую ветку |
| `phase` | Ветка на каждую фазу |
| `milestone` | Ветка на весь майлстоун |

## Примеры

```
/gsd:settings
> Установить mode=yolo, depth=comprehensive, profile=quality
```

## Итоги

- Конфигурация в `.planning/config.json`
- Три профиля моделей: quality, balanced, budget
- Режимы: yolo (авто) и interactive (ручной)
- Git-стратегии: none, phase, milestone
- Агенты можно включать/выключать для экономии токенов
LESSON

cat > "$BASE/ru/level-2-intermediate/05-multi-agent-support.md" << 'LESSON'
---
title: "Работа с разными агентами"
level: 2
lesson: 5
language: ru
tags: [gsd, claude-code, opencode, gemini]
---

# Работа с разными агентами

## Введение

GSD поддерживает три рантайма: Claude Code, OpenCode и Gemini CLI. Установка и команды одинаковые — различается только среда выполнения.

## Инструкции

### Поддерживаемые рантаймы

| Рантайм | Описание | Установка |
|---------|----------|-----------|
| **Claude Code** | Основной, от Anthropic | `--claude` |
| **OpenCode** | Open source, бесплатные модели | `--opencode` |
| **Gemini CLI** | Google Gemini | `--gemini` |

### Установка для конкретного рантайма

```bash
# Только Claude Code
npx get-shit-done-cc --claude --global

# Только OpenCode
npx get-shit-done-cc --opencode --global

# Только Gemini
npx get-shit-done-cc --gemini --global

# Все три
npx get-shit-done-cc --all --global
```

### Расположение файлов

| Рантайм | Глобальный путь |
|---------|-----------------|
| Claude Code | `~/.claude/` |
| OpenCode | `~/.config/opencode/` |
| Gemini | `~/.gemini/` |

### Различия в работе

Основная логика GSD одинакова для всех рантаймов. Различия:
- **Модели** — каждый рантайм использует свои модели
- **Команды** — синтаксис slash-команд может отличаться
- **Подагенты** — реализация параллелизма зависит от рантайма

## Примеры

```bash
# Установить для всех рантаймов
npx get-shit-done-cc --all --global

# Проверить в Claude Code
claude
/gsd:help

# Проверить в OpenCode
opencode
/gsd:help
```

## Итоги

- GSD работает в Claude Code, OpenCode и Gemini CLI
- Одна команда установки с флагами рантайма
- Логика и команды одинаковые
- Можно установить для всех рантаймов сразу
LESSON

# RU Level 3
cat > "$BASE/ru/level-3-advanced/01-architecture.md" << 'LESSON'
---
title: "Архитектура GSD"
level: 3
lesson: 1
language: ru
tags: [gsd, архитектура, система]
---

# Архитектура GSD

## Введение

Под капотом GSD — элегантная система из slash-команд, markdown-файлов и мульти-агентной оркестрации. Разберём как это устроено.

## Инструкции

### Компоненты системы

```
GSD
├── Slash-команды (интерфейс пользователя)
├── Оркестратор (координация)
├── Подагенты
│   ├── Исследователи (4 параллельных)
│   ├── Планировщик
│   ├── Чекер планов
│   ├── Исполнители (параллельные волны)
│   └── Верификатор
├── Состояние (.planning/)
│   ├── PROJECT.md
│   ├── REQUIREMENTS.md
│   ├── ROADMAP.md
│   ├── STATE.md
│   ├── config.json
│   └── Фазовые файлы
└── Git-интеграция (атомарные коммиты)
```

### Волновое выполнение

Планы группируются в «волны» по зависимостям:
- **Волна 1**: независимые планы → параллельно
- **Волна 2**: зависящие от Волны 1 → ждут, потом параллельно
- **Волна 3**: зависящие от Волны 2 → и так далее

### Жизненный цикл подагента

1. Оркестратор создаёт промпт с нужным контекстом
2. Подагент запускается в свежем контекстном окне
3. Выполняет задачу
4. Возвращает результат оркестратору
5. Оркестратор интегрирует и идёт дальше

### Файловая система как база данных

GSD не использует базу данных. Все состояние — markdown-файлы. Это даёт:
- Версионность через git
- Читаемость для человека
- Простоту отладки
- Портируемость

## Примеры

Типичная нагрузка контекста при выполнении фазы:
```
Главное окно: 30-40% (оркестрация)
Подагент-исследователь: 20-50% (исследование)
Подагент-планировщик: 30-60% (планирование)
Подагент-исполнитель: 40-80% (код)
```

## Итоги

- GSD = slash-команды + оркестратор + подагенты + файловое состояние
- Волновое выполнение максимизирует параллелизм
- Каждый подагент — свежий контекст
- Файлы как база данных — просто, версионно, читаемо
LESSON

cat > "$BASE/ru/level-3-advanced/02-advanced-patterns.md" << 'LESSON'
---
title: "Продвинутые паттерны"
level: 3
lesson: 2
language: ru
tags: [gsd, паттерны, продвинутый]
---

# Продвинутые паттерны

## Введение

Освоив основы, вы можете использовать продвинутые паттерны GSD для сложных проектов.

## Инструкции

### Браунфилд-проекты

Для существующей кодовой базы:

```
/gsd:map-codebase
```

Эта команда запускает параллельных агентов, которые анализируют:
- Стек технологий
- Архитектуру
- Конвенции кода
- Потенциальные проблемы

После маппинга `/gsd:new-project` учтёт существующий код.

### Вставка срочных фаз

```
/gsd:insert-phase 3
```

Вставляет фазу между существующими, перенумеровывая остальные. Полезно для хотфиксов.

### Управление майлстоунами

```
/gsd:complete-milestone   # Завершить, архивировать, тегнуть
/gsd:new-milestone        # Начать новый цикл
/gsd:audit-milestone      # Проверить достижение целей
```

### Debug-режим

```
/gsd:debug "Авторизация ломается при повторном логине"
```

Систематическая отладка с сохранением состояния.

### Quick mode с полной проверкой

```
/gsd:quick --full
```

Быстрые задачи, но с чекером планов и верификатором.

### Пропуск шагов

```
/gsd:plan-phase 1 --skip-research    # Без исследования
/gsd:plan-phase 1 --skip-verify      # Без проверки плана
```

## Примеры

Типичный workflow для зрелого проекта:
```
/gsd:map-codebase                    # Понять что есть
/gsd:new-milestone "v2.0"           # Новый цикл
/gsd:discuss-phase 1                 # Обсудить
/gsd:plan-phase 1                    # Спланировать
/gsd:execute-phase 1                 # Выполнить
/gsd:verify-work 1                   # Проверить
/gsd:insert-phase 2                  # Срочный фикс
/gsd:plan-phase 2                    # ...
```

## Итоги

- `/gsd:map-codebase` для существующих проектов
- Вставка срочных фаз через `insert-phase`
- Майлстоуны для версионирования
- Debug-режим для систематической отладки
- Quick --full для быстрых задач с проверкой
LESSON

cat > "$BASE/ru/level-3-advanced/03-prompt-customization.md" << 'LESSON'
---
title: "Кастомизация промптов"
level: 3
lesson: 3
language: ru
tags: [gsd, кастомизация, промпты]
---

# Кастомизация промптов

## Введение

GSD устанавливает slash-команды как markdown-файлы. Вы можете изучить и кастомизировать их для своих нужд.

## Инструкции

### Где хранятся команды

```
# Глобальная установка
~/.claude/commands/gsd/

# Локальная установка
./.claude/commands/gsd/
```

Каждая команда — markdown-файл с инструкциями для Claude.

### Кастомизация через CONTEXT.md

Самый простой способ кастомизации — через `/gsd:discuss-phase`. Ваши решения записываются в CONTEXT.md и влияют на все последующие шаги.

### Кастомизация через settings

```
/gsd:settings
```

Управляйте:
- Какие агенты включены
- Профили моделей
- Глубина планирования
- Git-стратегия

### Изменение команд напрямую

Для продвинутых пользователей — можно отредактировать сами markdown-файлы команд:

1. Откройте файл команды в `~/.claude/commands/gsd/`
2. Изучите структуру промпта
3. Добавьте или измените инструкции
4. Перезапустите Claude Code

> **Внимание:** При обновлении GSD ваши изменения будут перезаписаны. Делайте бэкап.

### Локальные переопределения

Используйте локальную установку для проектных кастомизаций:

```bash
npx get-shit-done-cc --claude --local
# Теперь редактируйте ./.claude/commands/gsd/
```

Локальные команды имеют приоритет над глобальными.

## Примеры

```bash
# Посмотреть структуру команд
ls ~/.claude/commands/gsd/

# Скопировать для кастомизации
cp -r ~/.claude/commands/gsd/ ./.claude/commands/gsd/
# Редактировать локальную копию
```

## Итоги

- Команды GSD — это markdown-файлы
- Кастомизация через CONTEXT.md — самый простой путь
- Можно редактировать файлы команд напрямую
- Локальные команды приоритетнее глобальных
- При обновлении GSD кастомизации перезаписываются
LESSON

cat > "$BASE/ru/level-3-advanced/04-workflow-integration.md" << 'LESSON'
---
title: "Интеграция в рабочий процесс"
level: 3
lesson: 4
language: ru
tags: [gsd, интеграция, workflow, ci-cd]
---

# Интеграция в рабочий процесс

## Введение

GSD можно интегрировать в существующие рабочие процессы: CI/CD, Docker, командную работу.

## Инструкции

### Docker и CI

Для контейнерных окружений используйте неинтерактивную установку:

```bash
# В Dockerfile
RUN npx get-shit-done-cc --claude --global

# Если ~ не раскрывается:
CLAUDE_CONFIG_DIR=/home/user/.claude npx get-shit-done-cc --global
```

### Git-стратегии для команд

Для командной работы рекомендуется стратегия `phase` или `milestone`:

```
/gsd:settings
> git.branching_strategy = phase
```

Каждая фаза создаёт ветку, merge при завершении фазы.

### Коммиты .planning/ в git

По умолчанию GSD коммитит `.planning/`. Это полезно:
- История решений
- Командная видимость
- Воспроизводимость

Отключить: `planning.commit_docs = false`.

### Безопасность

Защитите чувствительные файлы:

```json
{
  "permissions": {
    "deny": [
      "Read(.env)",
      "Read(.env.*)",
      "Read(**/*.pem)",
      "Read(**/*.key)"
    ]
  }
}
```

### Workflow для команд

```
Разработчик A: /gsd:new-project → создаёт спеку
Команда: Ревью REQUIREMENTS.md и ROADMAP.md
Разработчик A: /gsd:plan-phase 1 → создаёт планы
Разработчик B: /gsd:execute-phase 1 → выполняет
Разработчик A: /gsd:verify-work 1 → проверяет
```

## Примеры

```bash
# CI: установить и выполнить
npx get-shit-done-cc --claude --global
claude --dangerously-skip-permissions << 'EOF'
/gsd:resume-work
/gsd:execute-phase 3
EOF
```

## Итоги

- GSD работает в Docker и CI через неинтерактивную установку
- Git-стратегии phase/milestone для командной работы
- .planning/ в git даёт историю решений
- Защищайте чувствительные файлы через deny-список
LESSON

cat > "$BASE/ru/level-3-advanced/05-contributing.md" << 'LESSON'
---
title: "Контрибьюция в GSD"
level: 3
lesson: 5
language: ru
tags: [gsd, contributing, open-source]
---

# Контрибьюция в GSD

## Введение

GSD — open-source проект с MIT лицензией. Вы можете вносить изменения, исправлять баги и добавлять фичи.

## Инструкции

### Начало работы

```bash
git clone https://github.com/glittercowboy/get-shit-done.git
cd get-shit-done
node bin/install.js --claude --local
```

Это установит GSD локально для тестирования изменений.

### Структура проекта

```
get-shit-done/
├── bin/
│   └── install.js          # Установщик
├── prompts/
│   └── claude/
│       └── commands/gsd/    # Slash-команды
├── docs/
│   └── USER-GUIDE.md       # Документация
└── README.md
```

### Что можно контрибьютить

- **Команды** — новые slash-команды или улучшение существующих
- **Документация** — исправления, переводы, примеры
- **Баг-фиксы** — исправление проблем
- **Рантаймы** — поддержка новых AI-агентов
- **Тесты** — улучшение покрытия

### Процесс

1. Форкните репозиторий
2. Создайте ветку: `git checkout -b feature/my-feature`
3. Внесите изменения
4. Тестируйте локально через `node bin/install.js --claude --local`
5. Создайте Pull Request

### Сообщество

- [Discord](https://discord.gg/5JJgD5svVS) — вопросы и обсуждения
- [GitHub Issues](https://github.com/glittercowboy/get-shit-done/issues) — баги и предложения
- [Twitter/X](https://x.com/gsd_foundation) — новости

## Примеры

```bash
# Тестирование изменений в команде
cd get-shit-done
# Отредактировать prompts/claude/commands/gsd/some-command.md
node bin/install.js --claude --local
# Открыть Claude Code и протестировать /gsd:some-command
```

## Итоги

- GSD — open-source (MIT)
- Клонируйте и устанавливайте локально для разработки
- Контрибьютить можно команды, документацию, фиксы
- Сообщество в Discord
- PR через стандартный GitHub-процесс
LESSON

echo "Russian done"
