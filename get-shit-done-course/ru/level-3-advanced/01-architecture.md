---
title: "Архитектура GSD"
level: 3
lesson: 1
language: ru
tags: [gsd, архитектура, система]
---

# Архитектура GSD

## Введение

Под капотом GSD — элегантная система из slash-команд, markdown-файлов и мульти-агентной оркестрации. Разберём как это устроено.

## Инструкции

### Компоненты системы

```
GSD
├── Slash-команды (интерфейс пользователя)
├── Оркестратор (координация)
├── Подагенты
│   ├── Исследователи (4 параллельных)
│   ├── Планировщик
│   ├── Чекер планов
│   ├── Исполнители (параллельные волны)
│   └── Верификатор
├── Состояние (.planning/)
│   ├── PROJECT.md
│   ├── REQUIREMENTS.md
│   ├── ROADMAP.md
│   ├── STATE.md
│   ├── config.json
│   └── Фазовые файлы
└── Git-интеграция (атомарные коммиты)
```

### Волновое выполнение

Планы группируются в «волны» по зависимостям:
- **Волна 1**: независимые планы → параллельно
- **Волна 2**: зависящие от Волны 1 → ждут, потом параллельно
- **Волна 3**: зависящие от Волны 2 → и так далее

### Жизненный цикл подагента

1. Оркестратор создаёт промпт с нужным контекстом
2. Подагент запускается в свежем контекстном окне
3. Выполняет задачу
4. Возвращает результат оркестратору
5. Оркестратор интегрирует и идёт дальше

### Файловая система как база данных

GSD не использует базу данных. Все состояние — markdown-файлы. Это даёт:
- Версионность через git
- Читаемость для человека
- Простоту отладки
- Портируемость

## Примеры

Типичная нагрузка контекста при выполнении фазы:
```
Главное окно: 30-40% (оркестрация)
Подагент-исследователь: 20-50% (исследование)
Подагент-планировщик: 30-60% (планирование)
Подагент-исполнитель: 40-80% (код)
```

## Итоги

- GSD = slash-команды + оркестратор + подагенты + файловое состояние
- Волновое выполнение максимизирует параллелизм
- Каждый подагент — свежий контекст
- Файлы как база данных — просто, версионно, читаемо
