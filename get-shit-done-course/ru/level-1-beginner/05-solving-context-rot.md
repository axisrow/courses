---
title: "Как GSD решает проблему деградации контекста"
level: 1
lesson: 5
language: ru
tags: [gsd, context-rot, context-engineering]
---

# Как GSD решает проблему деградации контекста

## Введение

Context rot — главная проблема при длительной работе с AI-агентами. GSD решает её архитектурно, а не «подсказками».

## Как возникает context rot

1. Вы начинаете диалог — качество отличное
2. Контекстное окно заполняется на 50% — качество нормальное
3. На 70%+ — модель начинает «забывать» ранние решения
4. На 90%+ — ответы деградируют, код ломается

## Как GSD это решает

### 1. Свежий контекст для каждой задачи

Каждый план выполняется в отдельном подагенте с чистыми 200k токенами. Ничего лишнего — только задача и нужный контекст.

### 2. Файловое состояние вместо памяти диалога

```
PROJECT.md       → Что строим (всегда загружен)
REQUIREMENTS.md  → Что нужно сделать
ROADMAP.md       → Где мы в процессе
STATE.md         → Текущие решения и блокеры
PLAN.md          → Конкретная задача с XML-структурой
```

### 3. Волновое выполнение

Независимые задачи выполняются параллельно, зависимые — последовательно. Ни один агент не перегружен.

### 4. Атомарные коммиты

Каждая задача = один коммит. Если что-то сломалось — откатите один коммит, а не разбирайтесь в каше.

## Примеры

**Без GSD:**
```
Сообщение 1: "Создай API" → отлично
Сообщение 15: "Добавь авторизацию" → нормально
Сообщение 40: "Исправь баг" → забыл половину архитектуры
```

**С GSD:**
```
Фаза 1, План 1: API endpoints → свежий контекст → отлично
Фаза 1, План 2: Авторизация → свежий контекст → отлично
Фаза 2, План 1: Баг-фикс → свежий контекст → отлично
```

## Итоги

- Context rot — неизбежная проблема длинных диалогов
- GSD решает её через свежие контексты для каждой задачи
- Состояние хранится в файлах, а не в памяти диалога
- Атомарные коммиты дают чистую историю
- Качество остаётся стабильным независимо от объёма работы
